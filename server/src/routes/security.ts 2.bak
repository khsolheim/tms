/**
 * Security Management API Routes
 * 
 * API-endepunkter for å administrere sikkerhet:
 * - Rate limiting statistikk og kontroll
 * - API protection metrics
 * - IP whitelist/blacklist management
 * - Threat detection monitoring
 * - Security configuration
 */

import { Router, Request, Response } from 'express';
import { rateLimitManager } from '../middleware/rateLimiting';
import { protectionManager } from '../middleware/apiProtection';
import { verifyToken, sjekkRolle } from '../middleware/auth';
import { validateRequest } from '../middleware/requestValidation';
import { z } from 'zod';
import logger from '../utils/logger';

import { securityManager, getSecurityStatus } from '../middleware/security';
import { adminSecurityMiddleware } from '../middleware/security';

const router = Router();

// ============================================================================
// VALIDATION SCHEMAS
// ============================================================================

const ipAddressSchema = z.object({
  ip: z.string().ip('Ugyldig IP-adresse')
});

const rateLimitKeySchema = z.object({
  key: z.string().min(1, 'Nøkkel er pakrevd')
});

const threatTestSchema = z.object({
  input: z.string().min(1, 'Input er pakrevd for testing')
});

const thresholdUpdateSchema = z.object({
  errorThreshold: z.number().min(0).max(1).optional(),
  suspiciousThreshold: z.number().min(0).max(100).optional(),
  blockThreshold: z.number().min(0).max(100).optional()
});

// ============================================================================
// MIDDLEWARE
// ============================================================================

// Require admin role for all security endpoints
router.use(verifyToken);
router.use(sjekkRolle(['ADMIN', 'SUPER_ADMIN']));
// TEMPORARILY DISABLED FOR DEVELOPMENT - adminSecurityMiddleware causing rate limit issues
// router.use(adminSecurityMiddleware);

// ============================================================================
// RATE LIMITING MANAGEMENT
// ============================================================================

/**
 * GET /api/security/rate-limit/stats
 * Hent rate limiting statistikk
 */
router.get('/rate-limit/stats', async (req: Request, res: Response) => {
  try {
    const stats = rateLimitManager.getStats();
    
    logger.info('Rate limit stats requested', {
      requestId: (req as any).requestId,
      userId: (req as any).bruker?.id,
      statsRequested: true
    });

    res.json({
      success: true,
      data: {
        ...stats,
        uniqueIPs: Array.from(stats.uniqueIPs),
        topEndpoints: Object.fromEntries(stats.topEndpoints),
        adaptiveLimits: Object.fromEntries(stats.adaptiveLimits)
      }
    });
  } catch (error) {
    logger.error('Failed to get rate limit stats', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: (req as any).requestId
    });
    res.status(500).json({
      error: 'Kunne ikke hente rate limit statistikk',
      code: 'STATS_ERROR'
    });
  }
});

/**
 * GET /api/security/rate-limit/status/:key
 * Hent status for spesifikk rate limit nøkkel
 */
router.get('/rate-limit/status/:key', 
  validateRequest({ params: rateLimitKeySchema }),
  async (req: Request, res: Response) => {
    try {
      const { key } = req.params;
      const status = rateLimitManager.getStatus(key);

      if (!status) {
        return res.status(404).json({
          error: 'Rate limit nøkkel ikke funnet',
          code: 'KEY_NOT_FOUND'
        });
      }

      res.json({
        success: true,
        data: status
      });
    } catch (error) {
      logger.error('Failed to get rate limit status', {
        error: error instanceof Error ? error.message : 'Unknown error',
        key: req.params.key,
        requestId: (req as any).requestId
      });
      res.status(500).json({
        error: 'Kunne ikke hente rate limit status',
        code: 'STATUS_ERROR'
      });
    }
  }
);

/**
 * DELETE /api/security/rate-limit/reset/:key
 * Reset rate limit for spesifikk nøkkel
 */
router.delete('/rate-limit/reset/:key',
  validateRequest({ params: rateLimitKeySchema }),
  async (req: Request, res: Response) => {
    try {
      const { key } = req.params;
      rateLimitManager.reset(key);

      logger.info('Rate limit reset', {
        key,
        resetBy: (req as any).bruker?.id,
        requestId: (req as any).requestId
      });

      res.json({
        success: true,
        message: 'Rate limit tilbakestilt'
      });
    } catch (error) {
      logger.error('Failed to reset rate limit', {
        error: error instanceof Error ? error.message : 'Unknown error',
        key: req.params.key,
        requestId: (req as any).requestId
      });
      res.status(500).json({
        error: 'Kunne ikke tilbakestille rate limit',
        code: 'RESET_ERROR'
      });
    }
  }
);

/**
 * DELETE /api/security/rate-limit/reset-all
 * Reset alle rate limits
 */
router.delete('/rate-limit/reset-all', async (req: Request, res: Response) => {
  try {
    rateLimitManager.clearAll();

    logger.warn('All rate limits cleared', {
      clearedBy: (req as any).bruker?.id,
      requestId: (req as any).requestId
    });

    res.json({
      success: true,
      message: 'Alle rate limits tilbakestilt'
    });
  } catch (error) {
    logger.error('Failed to clear all rate limits', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: (req as any).requestId
    });
    res.status(500).json({
      error: 'Kunne ikke tilbakestille alle rate limits',
      code: 'CLEAR_ALL_ERROR'
    });
  }
});

// ============================================================================
// IP MANAGEMENT
// ============================================================================

/**
 * GET /api/security/ip/whitelist
 * Hent IP whitelist
 */
router.get('/ip/whitelist', async (req: Request, res: Response) => {
  try {
    const whitelist = rateLimitManager.whitelist.list();
    
    res.json({
      success: true,
      data: whitelist
    });
  } catch (error) {
    logger.error('Failed to get IP whitelist', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: (req as any).requestId
    });
    res.status(500).json({
      error: 'Kunne ikke hente IP whitelist',
      code: 'WHITELIST_ERROR'
    });
  }
});

/**
 * POST /api/security/ip/whitelist
 * Legg til IP i whitelist
 */
router.post('/ip/whitelist',
  validateRequest({ body: ipAddressSchema }),
  async (req: Request, res: Response) => {
    try {
      const { ip } = req.body;
      rateLimitManager.whitelist.add(ip);

      logger.info('IP added to whitelist', {
        ip,
        addedBy: (req as any).bruker?.id,
        requestId: (req as any).requestId
      });

      res.json({
        success: true,
        message: 'IP lagt til i whitelist'
      });
    } catch (error) {
      logger.error('Failed to add IP to whitelist', {
        error: error instanceof Error ? error.message : 'Unknown error',
        ip: req.body?.ip,
        requestId: (req as any).requestId
      });
      res.status(500).json({
        error: 'Kunne ikke legge til IP i whitelist',
        code: 'WHITELIST_ADD_ERROR'
      });
    }
  }
);

/**
 * DELETE /api/security/ip/whitelist/:ip
 * Fjern IP fra whitelist
 */
router.delete('/ip/whitelist/:ip', async (req: Request, res: Response) => {
  try {
    const { ip } = req.params;
    
    // Validate IP format
    const validation = ipAddressSchema.safeParse({ ip });
    if (!validation.success) {
      return res.status(400).json({
        error: 'Ugyldig IP-adresse format',
        code: 'INVALID_IP'
      });
    }

    rateLimitManager.whitelist.remove(ip);

    logger.info('IP removed from whitelist', {
      ip,
      removedBy: (req as any).bruker?.id,
      requestId: (req as any).requestId
    });

    res.json({
      success: true,
      message: 'IP fjernet fra whitelist'
    });
  } catch (error) {
    logger.error('Failed to remove IP from whitelist', {
      error: error instanceof Error ? error.message : 'Unknown error',
      ip: req.params.ip,
      requestId: (req as any).requestId
    });
    res.status(500).json({
      error: 'Kunne ikke fjerne IP fra whitelist',
      code: 'WHITELIST_REMOVE_ERROR'
    });
  }
});

/**
 * GET /api/security/ip/blacklist
 * Hent IP blacklist
 */
router.get('/ip/blacklist', async (req: Request, res: Response) => {
  try {
    const blacklist = rateLimitManager.blacklist.list();
    
    res.json({
      success: true,
      data: blacklist
    });
  } catch (error) {
    logger.error('Failed to get IP blacklist', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: (req as any).requestId
    });
    res.status(500).json({
      error: 'Kunne ikke hente IP blacklist',
      code: 'BLACKLIST_ERROR'
    });
  }
});

/**
 * POST /api/security/ip/blacklist
 * Legg til IP i blacklist
 */
router.post('/ip/blacklist',
  validateRequest({ body: ipAddressSchema }),
  async (req: Request, res: Response) => {
    try {
      const { ip } = req.body;
      rateLimitManager.blacklist.add(ip);

      logger.warn('IP added to blacklist', {
        ip,
        addedBy: (req as any).bruker?.id,
        requestId: (req as any).requestId
      });

      res.json({
        success: true,
        message: 'IP lagt til i blacklist'
      });
    } catch (error) {
      logger.error('Failed to add IP to blacklist', {
        error: error instanceof Error ? error.message : 'Unknown error',
        ip: req.body?.ip,
        requestId: (req as any).requestId
      });
      res.status(500).json({
        error: 'Kunne ikke legge til IP i blacklist',
        code: 'BLACKLIST_ADD_ERROR'
      });
    }
  }
);

/**
 * DELETE /api/security/ip/blacklist/:ip
 * Fjern IP fra blacklist
 */
router.delete('/ip/blacklist/:ip', async (req: Request, res: Response) => {
  try {
    const { ip } = req.params;
    
    // Validate IP format
    const validation = ipAddressSchema.safeParse({ ip });
    if (!validation.success) {
      return res.status(400).json({
        error: 'Ugyldig IP-adresse format',
        code: 'INVALID_IP'
      });
    }

    rateLimitManager.blacklist.remove(ip);

    logger.info('IP removed from blacklist', {
      ip,
      removedBy: (req as any).bruker?.id,
      requestId: (req as any).requestId
    });

    res.json({
      success: true,
      message: 'IP fjernet fra blacklist'
    });
  } catch (error) {
    logger.error('Failed to remove IP from blacklist', {
      error: error instanceof Error ? error.message : 'Unknown error',
      ip: req.params.ip,
      requestId: (req as any).requestId
    });
    res.status(500).json({
      error: 'Kunne ikke fjerne IP fra blacklist',
      code: 'BLACKLIST_REMOVE_ERROR'
    });
  }
});

/**
 * DELETE /api/security/ip/unblock
 * Fjern IP fra blokkert liste
 */
router.delete('/ip/unblock',
  validateRequest({ body: ipAddressSchema }),
  async (req: Request, res: Response) => {
    try {
      const { ip } = req.body;
      const wasBlocked = securityManager.unblockIP(ip);

      logger.info('IP unblock attempt', {
        ip,
        wasBlocked,
        unblockedBy: (req as any).bruker?.id,
        requestId: (req as any).requestId
      });

      res.json({
        success: true,
        message: wasBlocked ? 'IP fjernet fra blokkert liste' : 'IP var ikke blokkert',
        data: { ip, wasBlocked }
      });
    } catch (error) {
      logger.error('Failed to unblock IP', {
        error: error instanceof Error ? error.message : 'Unknown error',
        ip: req.body?.ip,
        requestId: (req as any).requestId
      });
      res.status(500).json({
        error: 'Kunne ikke fjerne IP fra blokkert liste',
        code: 'UNBLOCK_ERROR'
      });
    }
  }
);

/**
 * DELETE /api/security/ip/unblock-all
 * Fjern alle blokkerte IP-adresser
 */
router.delete('/ip/unblock-all', async (req: Request, res: Response) => {
  try {
    // Clear all blocked IPs
    const clearedCount = securityManager['blockedIPs'].size;
    securityManager['blockedIPs'].clear();

    logger.warn('All blocked IPs cleared', {
      clearedCount,
      clearedBy: (req as any).bruker?.id,
      requestId: (req as any).requestId
    });

    res.json({
      success: true,
      message: `${clearedCount} blokkerte IP-adresser fjernet`,
      data: { clearedCount }
    });
  } catch (error) {
    logger.error('Failed to clear all blocked IPs', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: (req as any).requestId
    });
    res.status(500).json({
      error: 'Kunne ikke fjerne alle blokkerte IP-adresser',
      code: 'CLEAR_ALL_BLOCKED_ERROR'
    });
  }
});

// ============================================================================
// PROTECTION METRICS
// ============================================================================

/**
 * GET /api/security/protection/metrics
 * Hent API protection metrics
 */
router.get('/protection/metrics', async (req: Request, res: Response) => {
  try {
    const metrics = protectionManager.getMetrics();
    
    logger.info('Protection metrics requested', {
      requestId: (req as any).requestId,
      userId: (req as any).bruker?.id
    });

    res.json({
      success: true,
      data: metrics
    });
  } catch (error) {
    logger.error('Failed to get protection metrics', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: (req as any).requestId
    });
    res.status(500).json({
      error: 'Kunne ikke hente protection metrics',
      code: 'METRICS_ERROR'
    });
  }
});

/**
 * DELETE /api/security/protection/metrics/reset
 * Reset protection metrics
 */
router.delete('/protection/metrics/reset', async (req: Request, res: Response) => {
  try {
    protectionManager.resetMetrics();

    logger.info('Protection metrics reset', {
      resetBy: (req as any).bruker?.id,
      requestId: (req as any).requestId
    });

    res.json({
      success: true,
      message: 'Protection metrics tilbakestilt'
    });
  } catch (error) {
    logger.error('Failed to reset protection metrics', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: (req as any).requestId
    });
    res.status(500).json({
      error: 'Kunne ikke tilbakestille protection metrics',
      code: 'METRICS_RESET_ERROR'
    });
  }
});

// ============================================================================
// THREAT DETECTION
// ============================================================================

/**
 * GET /api/security/threats/patterns
 * Hent alle threat detection patterns
 */
router.get('/threats/patterns', async (req: Request, res: Response) => {
  try {
    const patterns = protectionManager.getThreatPatterns();
    
    // Remove regex objects for JSON serialization
    const serializedPatterns = patterns.map(pattern => ({
      ...pattern,
      pattern: pattern.pattern.toString()
    }));

    res.json({
      success: true,
      data: serializedPatterns
    });
  } catch (error) {
    logger.error('Failed to get threat patterns', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: (req as any).requestId
    });
    res.status(500).json({
      error: 'Kunne ikke hente threat patterns',
      code: 'PATTERNS_ERROR'
    });
  }
});

/**
 * POST /api/security/threats/test
 * Test threat detection på input
 */
router.post('/threats/test',
  validateRequest({ body: threatTestSchema }),
  async (req: Request, res: Response) => {
    try {
      const { input } = req.body;
      const result = protectionManager.testThreatDetection(input);

      logger.info('Threat detection test performed', {
        inputLength: input.length,
        threatsDetected: result.threats.length,
        riskScore: result.riskScore,
        testedBy: (req as any).bruker?.id,
        requestId: (req as any).requestId
      });

      // Serialize threats for JSON response
      const serializedResult = {
        ...result,
        threats: result.threats.map(threat => ({
          ...threat,
          pattern: {
            ...threat.pattern,
            pattern: threat.pattern.pattern.toString()
          }
        }))
      };

      res.json({
        success: true,
        data: serializedResult
      });
    } catch (error) {
      logger.error('Failed to test threat detection', {
        error: error instanceof Error ? error.message : 'Unknown error',
        requestId: (req as any).requestId
      });
      res.status(500).json({
        error: 'Kunne ikke teste threat detection',
        code: 'THREAT_TEST_ERROR'
      });
    }
  }
);

// ============================================================================
// SECURITY OVERVIEW
// ============================================================================

/**
 * GET /api/security/overview
 * Hent komplett sikkerhetsoversikt
 */
router.get('/overview', async (req: Request, res: Response) => {
  try {
    const [rateLimitStats, protectionMetrics] = await Promise.all([
      rateLimitManager.getStats(),
      protectionManager.getMetrics()
    ]);

    const overview = {
      rateLimit: {
        ...rateLimitStats,
        uniqueIPs: Array.from(rateLimitStats.uniqueIPs),
        topEndpoints: Object.fromEntries(rateLimitStats.topEndpoints),
        adaptiveLimits: Object.fromEntries(rateLimitStats.adaptiveLimits)
      },
      protection: protectionMetrics,
      ipManagement: {
        whitelistCount: rateLimitManager.whitelist.list().length,
        blacklistCount: rateLimitManager.blacklist.list().length
      },
      timestamp: new Date().toISOString()
    };

    logger.info('Security overview requested', {
      requestId: (req as any).requestId,
      userId: (req as any).bruker?.id
    });

    res.json({
      success: true,
      data: overview
    });
  } catch (error) {
    logger.error('Failed to get security overview', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: (req as any).requestId
    });
    res.status(500).json({
      error: 'Kunne ikke hente sikkerhetsoversikt',
      code: 'OVERVIEW_ERROR'
    });
  }
});

// ============================================================================
// SECURITY MONITORING ROUTES (ADMIN ONLY)
// ============================================================================

// Hent sikkerhetsstatus
router.get('/status', getSecurityStatus);

// Hent detaljert sikkerhetsinformasjon
router.get('/details', (req: Request, res: Response) => {
  try {
    const status = securityManager.getSecurityStatus();
    
    // Legg til ekstra detaljer for admin
    const details = {
      ...status,
      systemInfo: {
        uptime: process.uptime(),
        memoryUsage: process.memoryUsage(),
        nodeVersion: process.version,
        platform: process.platform
      },
      securityConfig: {
        threatDetectionEnabled: true,
        ipBlockingEnabled: true,
        rateLimitingEnabled: true,
        corsEnabled: true,
        helmetEnabled: true
      }
    };

    res.json({
      success: true,
      data: details
    });
  } catch (error) {
    logger.error('Error getting security details', { error: error instanceof Error ? error.message : 'Unknown error' });
    res.status(500).json({
      success: false,
      error: 'Kunne ikke hente sikkerhetsdetaljer'
    });
  }
});

// Hent blokkerte IP-adresser
router.get('/blocked-ips', (req: Request, res: Response) => {
  try {
    // I en ekte implementasjon ville vi hente dette fra SecurityManager
    // For nå returnerer vi en mock-respons
    const blockedIPs = [
      {
        ip: '192.168.1.100',
        reason: 'Multiple SQL injection attempts',
        blockedAt: new Date(Date.now() - 30 * 60 * 1000).toISOString(),
        expiresAt: new Date(Date.now() + 30 * 60 * 1000).toISOString(),
        threatCount: 8
      }
    ];

    res.json({
      success: true,
      data: {
        blockedIPs,
        total: blockedIPs.length
      }
    });
  } catch (error) {
    logger.error('Error getting blocked IPs', { error: error instanceof Error ? error.message : 'Unknown error' });
    res.status(500).json({
      success: false,
      error: 'Kunne ikke hente blokkerte IP-adresser'
    });
  }
});

// Hent sikkerhetshendelser
router.get('/incidents', (req: Request, res: Response) => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 50;
    const severity = req.query.severity as string;
    const startDate = req.query.startDate as string;
    const endDate = req.query.endDate as string;

    // Mock-data for sikkerhetshendelser
    const incidents = [
      {
        id: 'incident_1',
        timestamp: new Date().toISOString(),
        ip: '192.168.1.100',
        userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        threatType: 'SQL_INJECTION_UNION',
        severity: 'CRITICAL',
        blocked: true,
        requestData: {
          method: 'POST',
          url: '/api/login',
          query: { username: "admin' UNION SELECT * FROM users--" }
        }
      },
      {
        id: 'incident_2',
        timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString(),
        ip: '10.0.0.50',
        userAgent: 'curl/7.68.0',
        threatType: 'COMMAND_INJECTION_BASIC',
        severity: 'HIGH',
        blocked: false,
        requestData: {
          method: 'GET',
          url: '/api/files',
          query: { path: '../../../etc/passwd' }
        }
      }
    ];

    // Filtrer basert på parametere
    let filteredIncidents = incidents;
    
    if (severity) {
      filteredIncidents = filteredIncidents.filter(i => i.severity === severity);
    }

    if (startDate) {
      const start = new Date(startDate);
      filteredIncidents = filteredIncidents.filter(i => new Date(i.timestamp) >= start);
    }

    if (endDate) {
      const end = new Date(endDate);
      filteredIncidents = filteredIncidents.filter(i => new Date(i.timestamp) <= end);
    }

    // Paginering
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedIncidents = filteredIncidents.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: {
        incidents: paginatedIncidents,
        pagination: {
          page,
          limit,
          total: filteredIncidents.length,
          pages: Math.ceil(filteredIncidents.length / limit)
        }
      }
    });
  } catch (error) {
    logger.error('Error getting security incidents', { error: error instanceof Error ? error.message : 'Unknown error' });
    res.status(500).json({
      success: false,
      error: 'Kunne ikke hente sikkerhetshendelser'
    });
  }
});

// Manuelt blokker IP-adresse
router.post('/block-ip', (req: Request, res: Response) => {
  try {
    const { ip, reason, duration } = req.body;

    if (!ip || !reason) {
      return res.status(400).json({
        success: false,
        error: 'IP-adresse og årsak er pakrevd'
      });
    }

    // Valider IP-format
    const ipRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
    if (!ipRegex.test(ip)) {
      return res.status(400).json({
        success: false,
        error: 'Ugyldig IP-adresse format'
      });
    }

    const blockDuration = duration || 60 * 60 * 1000; // Standard 1 time
    securityManager.blockIP(ip, `Manual block: ${reason}`, blockDuration);

    logger.info('IP manually blocked by admin', {
      ip,
      reason,
      duration: blockDuration,
      adminUser: (req as any).bruker?.id
    });

    res.json({
      success: true,
      message: `IP-adresse ${ip} er blokkert`,
      data: {
        ip,
        reason,
        duration: blockDuration,
        expiresAt: new Date(Date.now() + blockDuration).toISOString()
      }
    });
  } catch (error) {
    logger.error('Error blocking IP', { error: error instanceof Error ? error.message : 'Unknown error' });
    res.status(500).json({
      success: false,
      error: 'Kunne ikke blokkere IP-adresse'
    });
  }
});

// Fjern IP-blokkering
router.delete('/block-ip/:ip', (req: Request, res: Response) => {
  try {
    const { ip } = req.params;

    // Valider IP-format
    const ipRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
    if (!ipRegex.test(ip)) {
      return res.status(400).json({
        success: false,
        error: 'Ugyldig IP-adresse format'
      });
    }

    // I en ekte implementasjon ville vi fjerne IP fra SecurityManager
    // For nå logger vi bare handlingen
    logger.info('IP manually unblocked by admin', {
      ip,
      adminUser: (req as any).bruker?.id
    });

    res.json({
      success: true,
      message: `IP-adresse ${ip} er ikke lenger blokkert`
    });
  } catch (error) {
    logger.error('Error unblocking IP', { error: error instanceof Error ? error.message : 'Unknown error' });
    res.status(500).json({
      success: false,
      error: 'Kunne ikke fjerne IP-blokkering'
    });
  }
});

// Hent sikkerhetsmålinger
router.get('/metrics', (req: Request, res: Response) => {
  try {
    const timeRange = req.query.range as string || '24h';
    
    // Mock-data for sikkerhetsmålinger
    const metrics = {
      timeRange,
      requestsBlocked: {
        total: 156,
        byHour: [12, 8, 15, 23, 18, 9, 14, 22, 17, 11, 6, 3]
      },
      threatTypes: {
        'SQL_INJECTION': 45,
        'XSS': 32,
        'COMMAND_INJECTION': 28,
        'PATH_TRAVERSAL': 21,
        'NOSQL_INJECTION': 15,
        'OTHER': 15
      },
      topAttackerIPs: [
        { ip: '192.168.1.100', attempts: 23, blocked: true },
        { ip: '10.0.0.50', attempts: 18, blocked: false },
        { ip: '172.16.0.25', attempts: 15, blocked: true }
      ],
      responseTimeImpact: {
        averageWithoutSecurity: 45,
        averageWithSecurity: 52,
        overhead: 7
      }
    };

    res.json({
      success: true,
      data: metrics
    });
  } catch (error) {
    logger.error('Error getting security metrics', { error: error instanceof Error ? error.message : 'Unknown error' });
    res.status(500).json({
      success: false,
      error: 'Kunne ikke hente sikkerhetsmålinger'
    });
  }
});

// Test sikkerhetsmiddleware
router.post('/test-threat-detection', (req: Request, res: Response) => {
  try {
    const { testData } = req.body;

    if (!testData) {
      return res.status(400).json({
        success: false,
        error: 'testData er pakrevd'
      });
    }

    // Opprett en mock-forespørsel for testing
    const mockReq = {
      url: testData.url || '/test',
      originalUrl: testData.url || '/test',
      query: testData.query || {},
      body: testData.body || {},
      get: (header: string) => testData.headers?.[header] || ''
    } as any;

    const { threats, severity } = securityManager.detectThreats(mockReq);

    res.json({
      success: true,
      data: {
        threatsDetected: threats.length > 0,
        threats: threats.map(t => ({
          name: t.name,
          severity: t.severity,
          description: t.description
        })),
        overallSeverity: severity,
        wouldBlock: threats.some(t => t.severity === 'CRITICAL' || t.severity === 'HIGH')
      }
    });
  } catch (error) {
    logger.error('Error testing threat detection', { error: error instanceof Error ? error.message : 'Unknown error' });
    res.status(500).json({
      success: false,
      error: 'Kunne ikke teste trusseldeteksjon'
    });
  }
});

// Eksporter sikkerhetskonfigurasjon
router.get('/config', (req: Request, res: Response) => {
  try {
    const config = {
      threatDetection: {
        enabled: true,
        patterns: 15,
        alertThreshold: 5,
        blockDuration: '1 hour'
      },
      rateLimiting: {
        enabled: true,
        authLimit: '5 requests per 15 minutes',
        apiLimit: '100 requests per minute',
        adminLimit: '20 requests per minute'
      },
      cors: {
        enabled: true,
        allowedOrigins: ['http://localhost:3000', 'http://localhost:4000']
      },
      helmet: {
        enabled: true,
        hsts: true,
        csp: true,
        xssFilter: true
      }
    };

    res.json({
      success: true,
      data: config
    });
  } catch (error) {
    logger.error('Error getting security config', { error: error instanceof Error ? error.message : 'Unknown error' });
    res.status(500).json({
      success: false,
      error: 'Kunne ikke hente sikkerhetskonfigurasjon'
    });
  }
});

export default router; 