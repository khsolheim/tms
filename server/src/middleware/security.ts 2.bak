import { Request, Response, NextFunction } from 'express';
import DOMPurify from 'isomorphic-dompurify';
import path from 'path';
import logger from '../utils/logger';
import { ValidationError, ForbiddenError } from '../utils/errors';
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import { SecurityValidation } from '../utils/security-validation';
import { AppError } from '../utils/errors';
import cors from 'cors';
import { createRateLimit } from './rateLimiting';

/**
 * XSS Protection Middleware
 * Sanitiserer HTML input for √• forhindre XSS-angrep
 */
export const xssProtectionMiddleware = (req: Request, res: Response, next: NextFunction) => {
  try {
    // Sanitize request body
    if (req.body && typeof req.body === 'object') {
      req.body = sanitizeObject(req.body);
    }

    // Sanitize query parameters
    if (req.query && typeof req.query === 'object') {
      req.query = sanitizeObject(req.query);
    }

    // Sanitize route parameters
    if (req.params && typeof req.params === 'object') {
      req.params = sanitizeObject(req.params);
    }

    // Set security headers
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');

    next();
  } catch (error) {
    logger.error('XSS protection error', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: (req as any).requestId,
      url: req.originalUrl
    });
    next(error);
  }
};

/**
 * Recursively sanitize an object's string values
 */
function sanitizeObject(obj: any): any {
  if (typeof obj === 'string') {
    return sanitizeString(obj);
  }
  
  if (Array.isArray(obj)) {
    return obj.map(item => sanitizeObject(item));
  }
  
  if (obj && typeof obj === 'object') {
    const sanitized: any = {};
    for (const [key, value] of Object.entries(obj)) {
      // Also sanitize the key
      const sanitizedKey = sanitizeString(key);
      sanitized[sanitizedKey] = sanitizeObject(value);
    }
    return sanitized;
  }
  
  return obj;
}

/**
 * Sanitize a string to prevent XSS
 */
function sanitizeString(str: string): string {
  if (typeof str !== 'string') return str;
  
  // Use DOMPurify to sanitize HTML
  const cleaned = DOMPurify.sanitize(str, { 
    ALLOWED_TAGS: [], // No HTML tags allowed
    ALLOWED_ATTR: [] // No attributes allowed
  });
  
  // Additional cleaning for common injection patterns
  return cleaned
    .replace(/javascript:/gi, '') // Remove javascript: protocol
    .replace(/on\w+\s*=/gi, '') // Remove event handlers
    .replace(/<script[\s\S]*?<\/script>/gi, '') // Remove script tags
    .replace(/eval\s*\(/gi, '') // Remove eval calls
    .replace(/expression\s*\(/gi, ''); // Remove CSS expressions
}

/**
 * Path Traversal Protection Middleware
 * Forhindrer path traversal angrep (../../../etc/passwd)
 */
export const pathTraversalProtectionMiddleware = (req: Request, res: Response, next: NextFunction) => {
  try {
    // Check all string parameters for path traversal attempts
    const checkForPathTraversal = (value: string): boolean => {
      const dangerous = [
        '../', '..\\', '..%2f', '..%2F', '..%5c', '..%5C',
        '%2e%2e%2f', '%2e%2e%5c', '%2E%2E%2F', '%2E%2E%5C',
        '....//....\\\\', '....\\\\....//']
      
      return dangerous.some(pattern => 
        value.toLowerCase().includes(pattern.toLowerCase())
      );
    };

    // Check all request data
    const checkObjectForPathTraversal = (obj: any): void => {
      if (typeof obj === 'string' && checkForPathTraversal(obj)) {
        logger.warn('Path traversal attempt detected', {
          requestId: (req as any).requestId,
          url: req.originalUrl,
          ip: req.ip,
          userAgent: req.get('user-agent'),
          suspiciousValue: obj,
          userId: (req as any).bruker?.id
        });
        
        throw new ForbiddenError('Ugyldig filsti detektert');
      }
      
      if (Array.isArray(obj)) {
        obj.forEach(checkObjectForPathTraversal);
      } else if (obj && typeof obj === 'object') {
        Object.values(obj).forEach(checkObjectForPathTraversal);
      }
    };

    checkObjectForPathTraversal(req.body);
    checkObjectForPathTraversal(req.query);
    checkObjectForPathTraversal(req.params);

    next();
  } catch (error) {
    next(error);
  }
};

/**
 * SQL Injection Protection Middleware
 * Detekterer potensielle SQL injection fors√∏k
 */
export const sqlInjectionProtectionMiddleware = (req: Request, res: Response, next: NextFunction) => {
  try {
    const sqlInjectionPatterns = [
      /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|CREATE|ALTER|EXEC|EXECUTE)\b)/gi,
      /(\b(OR|AND)\s+\d+\s*=\s*\d+)/gi,
      /('|("|`|;|\/\*|\*\/|--|\|\|))/gi,
      /(INFORMATION_SCHEMA|SYSOBJECTS|SYSCOLUMNS)/gi,
      /(CHAR\(|CHR\(|ASCII\(|SUBSTRING\()/gi,
      /(LOAD_FILE\(|INTO\s+OUTFILE|INTO\s+DUMPFILE)/gi,
      /(BENCHMARK\(|SLEEP\(|pg_sleep\()/gi
    ];

    const checkForSQLInjection = (value: string): boolean => {
      return sqlInjectionPatterns.some(pattern => pattern.test(value));
    };

    const checkObjectForSQLInjection = (obj: any): void => {
      if (typeof obj === 'string' && checkForSQLInjection(obj)) {
        logger.warn('SQL injection attempt detected', {
          requestId: (req as any).requestId,
          url: req.originalUrl,
          ip: req.ip,
          userAgent: req.get('user-agent'),
          suspiciousValue: obj.substring(0, 100), // Log only first 100 chars
          userId: (req as any).bruker?.id
        });
        
        throw new ForbiddenError('Ugyldig SQL-kommando detektert');
      }
      
      if (Array.isArray(obj)) {
        obj.forEach(checkObjectForSQLInjection);
      } else if (obj && typeof obj === 'object') {
        Object.values(obj).forEach(checkObjectForSQLInjection);
      }
    };

    checkObjectForSQLInjection(req.body);
    checkObjectForSQLInjection(req.query);
    checkObjectForSQLInjection(req.params);

    next();
  } catch (error) {
    next(error);
  }
};

/**
 * Command Injection Protection Middleware
 * Forhindrer command injection angrep
 */
export const commandInjectionProtectionMiddleware = (req: Request, res: Response, next: NextFunction) => {
  try {
    const commandInjectionPatterns = [
      /(\||&|;|\$\(|\`|<|>)/g,
      /(nc|netcat|wget|curl|chmod|rm|mv|cp|cat|ls|ps|kill|sudo|su)/gi,
      /(eval|exec|system|shell_exec|passthru|proc_open)/gi,
      /(\${|%{|#{|\|\|)/g
    ];

    const checkForCommandInjection = (value: string): boolean => {
      return commandInjectionPatterns.some(pattern => pattern.test(value));
    };

    const checkObjectForCommandInjection = (obj: any): void => {
      if (typeof obj === 'string' && checkForCommandInjection(obj)) {
        logger.warn('Command injection attempt detected', {
          requestId: (req as any).requestId,
          url: req.originalUrl,
          ip: req.ip,
          userAgent: req.get('user-agent'),
          suspiciousValue: obj.substring(0, 100),
          userId: (req as any).bruker?.id
        });
        
        throw new ForbiddenError('Ugyldig kommando detektert');
      }
      
      if (Array.isArray(obj)) {
        obj.forEach(checkObjectForCommandInjection);
      } else if (obj && typeof obj === 'object') {
        Object.values(obj).forEach(checkObjectForCommandInjection);
      }
    };

    checkObjectForCommandInjection(req.body);
    checkObjectForCommandInjection(req.query);
    checkObjectForCommandInjection(req.params);

    next();
  } catch (error) {
    next(error);
  }
};

/**
 * Request Size Validation Middleware
 * Begrenser st√∏rrelsen p√• requests for √• forhindre DoS
 */
export const requestSizeValidationMiddleware = (options: {
  maxBodySize?: number; // bytes
  maxQueryLength?: number; // characters
  maxUrlLength?: number; // characters
  maxHeaderSize?: number; // bytes
} = {}) => {
  const {
    maxBodySize = 10 * 1024 * 1024, // 10MB default
    maxQueryLength = 2048,
    maxUrlLength = 2048,
    maxHeaderSize = 8192
  } = options;

  return (req: Request, res: Response, next: NextFunction) => {
    try {
      // Check URL length
      if (req.originalUrl.length > maxUrlLength) {
        logger.warn('Oversized URL detected', {
          requestId: (req as any).requestId,
          urlLength: req.originalUrl.length,
          maxAllowed: maxUrlLength,
          ip: req.ip
        });
        
        throw new ValidationError('URL er for lang');
      }

      // Check query string length
      const queryString = JSON.stringify(req.query);
      if (queryString.length > maxQueryLength) {
        logger.warn('Oversized query string detected', {
          requestId: (req as any).requestId,
          queryLength: queryString.length,
          maxAllowed: maxQueryLength,
          ip: req.ip
        });
        
        throw new ValidationError('Query parametere er for lange');
      }

      // Check headers size
      const headersSize = JSON.stringify(req.headers).length;
      if (headersSize > maxHeaderSize) {
        logger.warn('Oversized headers detected', {
          requestId: (req as any).requestId,
          headersSize,
          maxAllowed: maxHeaderSize,
          ip: req.ip
        });
        
        throw new ValidationError('Request headers er for store');
      }

      // Body size is typically handled by express.json() and express.urlencoded()
      // but we can add additional validation here
      if (req.headers['content-length']) {
        const contentLength = parseInt(req.headers['content-length']);
        if (contentLength > maxBodySize) {
          logger.warn('Oversized body detected', {
            requestId: (req as any).requestId,
            bodySize: contentLength,
            maxAllowed: maxBodySize,
            ip: req.ip
          });
          
          throw new ValidationError('Request body er for stor');
        }
      }

      next();
    } catch (error) {
      next(error);
    }
  };
};

/**
 * Content Type Validation Middleware
 * Validerer at Content-Type header matcher forventet type
 */
export const contentTypeValidationMiddleware = (allowedTypes: string[] = [
  'application/json',
  'application/x-www-form-urlencoded',
  'multipart/form-data'
]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    // Skip validation for GET requests without body
    if (['GET', 'HEAD', 'OPTIONS'].includes(req.method)) {
      return next();
    }

    const contentType = req.headers['content-type'];
    
    if (!contentType) {
      logger.warn('Missing Content-Type header', {
        requestId: (req as any).requestId,
        method: req.method,
        url: req.originalUrl,
        ip: req.ip
      });
      
      return next(new ValidationError('Content-Type header er pakrevd'));
    }

    // Extract base content type (without charset, boundary, etc.)
    const baseContentType = contentType.split(';')[0].trim().toLowerCase();
    
    if (!allowedTypes.includes(baseContentType)) {
      logger.warn('Invalid Content-Type', {
        requestId: (req as any).requestId,
        contentType: baseContentType,
        allowedTypes,
        ip: req.ip
      });
      
      return next(new ValidationError(`Ugyldig Content-Type: ${baseContentType}`));
    }

    next();
  };
};

/**
 * User Agent Validation Middleware
 * Blokkerer kjente bot patterns og mistenkelige user agents
 */
export const userAgentValidationMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const userAgent = req.get('user-agent') || '';
  
  // Suspicious patterns
  const suspiciousPatterns = [
    /sqlmap/i,
    /nikto/i,
    /nmap/i,
    /masscan/i,
    /zgrab/i,
    /curl.*python/i,
    /python.*requests/i,
    /bot.*attack/i,
    /hack/i,
    /exploit/i
  ];

  // Check for suspicious patterns
  if (suspiciousPatterns.some(pattern => pattern.test(userAgent))) {
    logger.warn('Suspicious user agent detected', {
      requestId: (req as any).requestId,
      userAgent,
      ip: req.ip,
      url: req.originalUrl
    });
    
    // Could return 403 or continue with extra logging
    // For now, just log and continue
  }

  // Block completely empty user agents for API endpoints
  if (!userAgent && req.originalUrl.startsWith('/api/')) {
    logger.warn('Empty user agent on API request', {
      requestId: (req as any).requestId,
      ip: req.ip,
      url: req.originalUrl
    });
  }

  next();
};

/**
 * IP Validation Middleware
 * Kan brukes til √• blokkere kjente ondsinnede IP-adresser
 */
export const ipValidationMiddleware = (blockedIPs: string[] = []) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const forwarded = req.headers['x-forwarded-for'] as string;
    const ip = forwarded ? forwarded.split(',')[0].trim() : req.connection.remoteAddress;
    
    if (ip && blockedIPs.includes(ip)) {
      logger.warn('Blocked IP address attempt', {
        requestId: (req as any).requestId,
        ip,
        url: req.originalUrl,
        userAgent: req.get('user-agent')
      });
      
      throw new ForbiddenError('Tilgang nektet');
    }
    
    next();
  };
};

/**
 * Security Headers Middleware
 * Setter sikkerhetsorienterte HTTP headers
 */
export const securityHeadersMiddleware = (req: Request, res: Response, next: NextFunction) => {
  // Content Security Policy
  res.setHeader('Content-Security-Policy', 
    "default-src 'self'; " +
    "script-src 'self' 'unsafe-inline' 'unsafe-eval'; " +
    "style-src 'self' 'unsafe-inline'; " +
    "img-src 'self' data: https:; " +
    "font-src 'self' https:; " +
    "connect-src 'self'; " +
    "frame-ancestors 'none';"
  );

  // Other security headers
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');
  
  // Only set HSTS in production
  if (process.env.NODE_ENV === 'production') {
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
  }

  next();
};

/**
 * Combined security middleware
 * Kombinerer alle security middleware i riktig rekkefolge
 */
export const combinedSecurityMiddleware = [
  securityHeadersMiddleware,
  userAgentValidationMiddleware,
  requestSizeValidationMiddleware(),
  pathTraversalProtectionMiddleware,
  sqlInjectionProtectionMiddleware,
  commandInjectionProtectionMiddleware,
  xssProtectionMiddleware
];

/**
 * Input sanitization middleware
 */
export const sanitizeInput = (req: Request, res: Response, next: NextFunction) => {
  try {
    // Sanitize request body
    if (req.body && typeof req.body === 'object') {
      req.body = SecurityValidation.sanitizeAllInputs(req.body);
    }

    next();
  } catch (error) {
    logger.error('Error in input sanitization middleware', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: (req as any).requestId,
      ip: req.ip
    });
    next(new AppError('Feil ved behandling av input', 400, 'VALIDATION_ERROR'));
  }
};

/**
 * General API rate limiting
 */
export const generalRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 1000, // limit each IP to 1000 requests per windowMs
  message: 'For mange API kall, pr√∏v igjen om 15 minutter'
});

/**
 * Authentication rate limiting
 */
export const authRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // limit each IP to 10 login attempts per windowMs
  message: 'For mange innloggingsfors√∏k, pr√∏v igjen om 15 minutter'
});

/**
 * Security headers configuration
 */
export const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      scriptSrc: ["'self'"],
      objectSrc: ["'none'"]
    }
  }
});

// ============================================================================
// SECURITY INTERFACES & TYPES
// ============================================================================

export interface SecurityConfig {
  enableThreatDetection: boolean;
  enableIPBlocking: boolean;
  enableRequestValidation: boolean;
  enableCSRFProtection: boolean;
  enableXSSProtection: boolean;
  enableSQLInjectionProtection: boolean;
  blockDuration: number;
  alertThreshold: number;
  maxRequestSize: string;
  allowedOrigins: string[];
  trustedProxies: string[];
}

export interface ThreatPattern {
  name: string;
  pattern: RegExp;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  description: string;
}

export interface SecurityIncident {
  id: string;
  ip: string;
  userAgent: string;
  timestamp: Date;
  threatType: string;
  severity: string;
  blocked: boolean;
  requestData: {
    method: string;
    url: string;
    headers: Record<string, string>;
    body?: any;
    query?: any;
  };
}

// ============================================================================
// SECURITY CONFIGURATION
// ============================================================================

export const DEFAULT_SECURITY_CONFIG: SecurityConfig = {
  enableThreatDetection: true,
  enableIPBlocking: true,
  enableRequestValidation: true,
  enableCSRFProtection: true,
  enableXSSProtection: true,
  enableSQLInjectionProtection: true,
  blockDuration: 60 * 60 * 1000, // 1 time
  alertThreshold: 10, // √òkt fra 5 til 10 for √• redusere falske positive
  maxRequestSize: '10mb',
  allowedOrigins: [
    'http://localhost:3000',
    'http://localhost:4000',
    'https://tms.example.com'
  ],
  trustedProxies: ['127.0.0.1', '::1', 'localhost']
};

// ============================================================================
// THREAT DETECTION PATTERNS
// ============================================================================

export const THREAT_PATTERNS: ThreatPattern[] = [
  // SQL Injection - mer spesifikke m√∏nstre
  {
    name: 'SQL_INJECTION_UNION',
    pattern: /(\bUNION\b.*\bSELECT\b)/i,
    severity: 'CRITICAL',
    description: 'SQL UNION injection attempt'
  },
  {
    name: 'SQL_INJECTION_BASIC',
    pattern: /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC)\b.*(\bFROM\b|\bINTO\b|\bSET\b|\bWHERE\b).*['"`;])/i,
    severity: 'HIGH',
    description: 'Basic SQL injection attempt'
  },
  {
    name: 'SQL_INJECTION_BOOLEAN',
    pattern: /(\b(OR|AND)\s+['"]?\d+['"]?\s*=\s*['"]?\d+['"]?)/i,
    severity: 'HIGH',
    description: 'Boolean-based SQL injection'
  },

  // XSS (Cross-Site Scripting) - mer spesifikke m√∏nstre
  {
    name: 'XSS_SCRIPT_TAG',
    pattern: /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
    severity: 'CRITICAL',
    description: 'Script tag XSS attempt'
  },
  {
    name: 'XSS_JAVASCRIPT_PROTOCOL',
    pattern: /javascript:\s*[^;]/i,
    severity: 'HIGH',
    description: 'JavaScript protocol XSS'
  },
  {
    name: 'XSS_EVENT_HANDLER',
    pattern: /on(click|load|error|focus|blur|submit|change|mouseover)\s*=/i,
    severity: 'HIGH',
    description: 'Event handler XSS'
  },

  // Path Traversal - mer spesifikke m√∏nstre
  {
    name: 'PATH_TRAVERSAL_BASIC',
    pattern: /\.\.[\/\\]{2,}/,
    severity: 'HIGH',
    description: 'Basic path traversal attempt'
  },
  {
    name: 'PATH_TRAVERSAL_ENCODED',
    pattern: /%2e%2e%2f/i,
    severity: 'HIGH',
    description: 'URL-encoded path traversal'
  },

  // Command Injection - mer spesifikke m√∏nstre
  {
    name: 'COMMAND_INJECTION_CRITICAL',
    pattern: /[;&|`$(){}[\]]\s*(cat|ls|pwd|whoami|id|uname|ps|netstat|ifconfig|ping|wget|curl|nc|nmap|rm|chmod|chown)\b/i,
    severity: 'CRITICAL',
    description: 'Command injection with system commands'
  },

  // NoSQL Injection
  {
    name: 'NOSQL_INJECTION',
    pattern: /\$where|\$ne|\$gt|\$lt|\$regex/i,
    severity: 'HIGH',
    description: 'NoSQL injection attempt'
  }
];

// ============================================================================
// SECURITY MANAGER
// ============================================================================

export class SecurityManager {
  private config: SecurityConfig;
  private blockedIPs: Map<string, { until: Date; reason: string; count: number }> = new Map();
  private threatCounts: Map<string, { count: number; lastThreat: Date; incidents: SecurityIncident[] }> = new Map();
  private incidents: SecurityIncident[] = [];
  private cleanupInterval: NodeJS.Timeout | null = null;

  constructor(config: Partial<SecurityConfig> = {}) {
    this.config = { ...DEFAULT_SECURITY_CONFIG, ...config };
    this.startCleanupTasks();
  }

  private startCleanupTasks(): void {
    // Rydd opp gamle hendelser og blokkerte IP-er hver 10. minutt
    this.cleanupInterval = setInterval(() => {
      this.cleanupExpiredBlocks();
      this.cleanupOldIncidents();
    }, 10 * 60 * 1000);
  }

  private cleanupExpiredBlocks(): void {
    const now = new Date();
    for (const [ip, blockInfo] of this.blockedIPs.entries()) {
      if (now > blockInfo.until) {
        this.blockedIPs.delete(ip);
        logger.info('IP unblocked after timeout', { ip, reason: blockInfo.reason });
      }
    }
  }

  private cleanupOldIncidents(): void {
    const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    this.incidents = this.incidents.filter(incident => incident.timestamp > oneWeekAgo);
    
    // Rydd opp trusseldata
    for (const [ip, data] of this.threatCounts.entries()) {
      if (data.lastThreat < oneWeekAgo) {
        this.threatCounts.delete(ip);
      }
    }
  }

  // Sjekk om IP er whitelisted (trusted)
  private isWhitelistedIP(ip: string): boolean {
    const whitelistedIPs = [
      '127.0.0.1',
      '::1',
      'localhost',
      '::ffff:127.0.0.1'
    ];
    
    return whitelistedIPs.includes(ip) || 
           this.config.trustedProxies.includes(ip) ||
           ip.startsWith('192.168.') || // Local network
           ip.startsWith('10.') ||      // Private network
           ip.startsWith('172.16.');    // Private network
  }

  // Fjern IP fra blokkert liste (for admin/debugging)
  unblockIP(ip: string): boolean {
    const wasBlocked = this.blockedIPs.has(ip);
    this.blockedIPs.delete(ip);
    
    if (wasBlocked) {
      logger.info('IP manually unblocked', { ip });
    }
    
    return wasBlocked;
  }

  // Sjekk om IP er blokkert
  isIPBlocked(ip: string): boolean {
    // DEVELOPMENT: COMPLETELY DISABLED - NO IP BLOCKING EVER
    return false;
  }

  // Blokker IP
  blockIP(ip: string, reason: string, duration?: number): void {
    // DEVELOPMENT: COMPLETELY DISABLED - NEVER BLOCK ANY IPs
    return;
  }

  // Detekter trusler i foresp√∏rsel
  detectThreats(req: Request): { threats: ThreatPattern[]; severity: string } {
    // DEVELOPMENT: COMPLETELY DISABLED - NO THREAT DETECTION EVER
    return { threats: [], severity: 'NONE' };
  }

  // H√•ndter oppdagede trusler
  handleThreats(req: Request, threats: ThreatPattern[], severity: string): boolean {
    // DEVELOPMENT: COMPLETELY DISABLED - NEVER BLOCK ANYTHING
    return false;

    const ip = this.getClientIP(req);
    const now = new Date();

    // Opprett sikkerhetshendelse
    const incident: SecurityIncident = {
      id: `incident_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ip,
      userAgent: req.get('User-Agent') || 'Unknown',
      timestamp: now,
      threatType: threats.map(t => t.name).join(', '),
      severity,
      blocked: false,
      requestData: {
        method: req.method,
        url: req.url,
        headers: this.sanitizeHeaders(req.headers),
        body: this.sanitizeData(req.body),
        query: this.sanitizeData(req.query)
      }
    };

    // Oppdater trusseldata for IP
    const threatData = this.threatCounts.get(ip) || { count: 0, lastThreat: now, incidents: [] };
    threatData.count += threats.length;
    threatData.lastThreat = now;
    threatData.incidents.push(incident);
    this.threatCounts.set(ip, threatData);

    // Lagre hendelse
    this.incidents.push(incident);

    logger.warn('Security threats detected', {
      ip,
      threats: threats.map(t => ({ name: t.name, severity: t.severity })),
      totalCount: threatData.count,
      incident: incident.id
    });

    // Blokker IP hvis trusselgrensen er n√•dd
    if (threatData.count >= this.config.alertThreshold) {
      this.blockIP(ip, `Multiple threats detected: ${threats.map(t => t.name).join(', ')}`);
      incident.blocked = true;
      
      // Send admin-varsling
      this.sendSecurityAlert(incident, threatData);
      
      return true; // Blokkert
    }

    return false; // Ikke blokkert
  }

  private getClientIP(req: Request): string {
    return req.ip || 
           req.connection.remoteAddress || 
           req.socket.remoteAddress || 
           (req.connection as any)?.socket?.remoteAddress || 
           'unknown';
  }

  private sanitizeHeaders(headers: any): Record<string, string> {
    const sanitized: Record<string, string> = {};
    const allowedHeaders = ['user-agent', 'referer', 'accept', 'content-type', 'x-forwarded-for'];
    
    for (const [key, value] of Object.entries(headers)) {
      if (allowedHeaders.includes(key.toLowerCase()) && typeof value === 'string') {
        sanitized[key] = value.substring(0, 500); // Begrens lengde
      }
    }
    
    return sanitized;
  }

  private sanitizeData(data: any): any {
    if (!data) return null;
    
    try {
      const str = JSON.stringify(data);
      return str.length > 1000 ? str.substring(0, 1000) + '...' : JSON.parse(str);
    } catch {
      return '[Invalid JSON]';
    }
  }

  private async sendSecurityAlert(incident: SecurityIncident, threatData: any): Promise<void> {
    try {
      logger.error('SECURITY ALERT: Critical threat activity detected', {
        incident: {
          id: incident.id,
          ip: incident.ip,
          severity: incident.severity,
          threatType: incident.threatType,
          timestamp: incident.timestamp.toISOString()
        },
        threatData: {
          totalCount: threatData.count,
          recentIncidents: threatData.incidents.length
        },
        action: 'IP_BLOCKED'
      });

      // Her kunne vi integrere med e-post, Slack, eller andre varslingssystemer
      // await this.sendEmailAlert(incident);
      // await this.sendSlackAlert(incident);
      
    } catch (error) {
      logger.error('Failed to send security alert', { 
        error: error instanceof Error ? error.message : 'Unknown error',
        incidentId: incident.id 
      });
    }
  }

  // Hent sikkerhetsstatus
  getSecurityStatus(): {
    blockedIPs: number;
    activeThreats: number;
    totalIncidents: number;
    recentIncidents: number;
    topThreats: Array<{ type: string; count: number }>;
  } {
    const now = new Date();
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
    
    const recentIncidents = this.incidents.filter(i => i.timestamp > oneHourAgo);
    
    // Tell opp trusseltyper
    const threatCounts = new Map<string, number>();
    for (const incident of this.incidents) {
      const types = incident.threatType.split(', ');
      for (const type of types) {
        threatCounts.set(type, (threatCounts.get(type) || 0) + 1);
      }
    }
    
    const topThreats = Array.from(threatCounts.entries())
      .map(([type, count]) => ({ type, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    return {
      blockedIPs: this.blockedIPs.size,
      activeThreats: this.threatCounts.size,
      totalIncidents: this.incidents.length,
      recentIncidents: recentIncidents.length,
      topThreats
    };
  }

  // Rydd opp ressurser
  destroy(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }
}

// ============================================================================
// SECURITY MIDDLEWARE
// ============================================================================

// Global security manager
const securityManager = new SecurityManager();

// DEVELOPMENT: Clear all blocked IPs and threats on startup
securityManager['blockedIPs'].clear();
securityManager['threatCounts'].clear();
securityManager['incidents'].length = 0;
console.log('üü¢ DEVELOPMENT: Cleared all security state on startup');

// Hovedsikkerhetsmiddleware
export const securityMiddleware = (req: Request, res: Response, next: NextFunction) => {
  // DEVELOPMENT: ALWAYS DISABLED - Skip all security checks
  if (process.env.NODE_ENV === 'development' || process.env.DISABLE_SECURITY === 'true') {
    console.log('üü¢ DEVELOPMENT: Security middleware COMPLETELY DISABLED, allowing all requests for', req.path);
    return next();
  }
  
  // PRODUCTION: Full security checks (unreachable code in development)
  const ip = securityManager['getClientIP'](req);
  
  if (securityManager['isWhitelistedIP'](ip)) {
    return next();
  }
  
  if (securityManager.isIPBlocked(ip)) {
    console.log('‚ùå SECURITY MIDDLEWARE: Blocking IP', ip, 'for path', req.path);
    logger.warn('Blocked IP attempted access', { ip, path: req.path });
    return res.status(403).json({
      success: false,
      error: 'Tilgang nektet p√• grunn av sikkerhetshendelser',
      code: 'IP_BLOCKED'
    });
  }

  const { threats, severity } = securityManager.detectThreats(req);
  
  if (threats.length > 0) {
    const blocked = securityManager.handleThreats(req, threats, severity);
    
    if (blocked) {
      return res.status(400).json({
        success: false,
        error: 'Foresp√∏rsel blokkert p√• grunn av sikkerhetstrussel',
        code: 'THREAT_DETECTED'
      });
    }
  }

  next();
};

// CORS-konfigurasjon
export const corsMiddleware = cors({
  origin: (origin, callback) => {
    // Tillat foresp√∏rsler uten origin (f.eks. mobile apps)
    if (!origin) return callback(null, true);
    
    if (DEFAULT_SECURITY_CONFIG.allowedOrigins.includes(origin)) {
      return callback(null, true);
    }
    
    logger.warn('CORS blocked request', { origin });
    return callback(new Error('Not allowed by CORS'));
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept', 'Origin'],
  exposedHeaders: ['X-RateLimit-Limit', 'X-RateLimit-Remaining', 'X-RateLimit-Reset']
});

// Helmet-konfigurasjon for sikkerhetshoder
export const helmetMiddleware = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:"],
      scriptSrc: ["'self'"],
      connectSrc: ["'self'", "ws:", "wss:"],
      frameSrc: ["'none'"],
      objectSrc: ["'none'"],
      upgradeInsecureRequests: []
    }
  },
  crossOriginEmbedderPolicy: false, // Kan for√•rsake problemer med noen integrasjoner
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
});

// Rate limiting for forskjellige endepunkter
export const authSecurityMiddleware = createRateLimit({
  windowMs: 1 * 60 * 1000,  // 1 minutt (redusert fra 15)
  maxRequests: 100,         // 100 fors√∏k (√∏kt fra 5) 
  message: 'For mange autentiseringsfors√∏k. Pr√∏v igjen senere.',
  keyGenerator: (req) => `auth:${securityManager['getClientIP'](req)}`,
  onLimitReached: (req, res) => {
    // DEVELOPMENT: Ikke blokker IP for autentiseringsfors√∏k
    // const ip = securityManager['getClientIP'](req);
    // securityManager.blockIP(ip, 'Too many authentication attempts', 30 * 60 * 1000);
  }
});

export const apiSecurityMiddleware = createRateLimit({
  windowMs: 60 * 1000,      // 1 minutt
  maxRequests: 100,         // 100 foresp√∏rsler
  message: 'For mange API-foresp√∏rsler. Pr√∏v igjen senere.',
  keyGenerator: (req) => {
    const userId = (req as any).bruker?.id;
    const ip = securityManager['getClientIP'](req);
    return userId ? `api:user:${userId}` : `api:ip:${ip}`;
  }
});

export const adminSecurityMiddleware = createRateLimit({
  windowMs: 60 * 1000,      // 1 minutt
  maxRequests: 200,         // 200 foresp√∏rsler (√∏kt fra 20)
  message: 'For mange admin-foresp√∏rsler. Pr√∏v igjen senere.',
  keyGenerator: (req) => `admin:${(req as any).bruker?.id || securityManager['getClientIP'](req)}`
});

// ============================================================================
// SECURITY ROUTES & MONITORING
// ============================================================================

export const getSecurityStatus = (req: Request, res: Response) => {
  try {
    const status = securityManager.getSecurityStatus();
    res.json({
      success: true,
      data: status
    });
  } catch (error) {
    logger.error('Error getting security status', { error: error instanceof Error ? error.message : 'Unknown error' });
    res.status(500).json({
      success: false,
      error: 'Kunne ikke hente sikkerhetsstatus'
    });
  }
};

// Eksporter security manager for testing og admin-funksjoner
export { securityManager };

// Graceful shutdown
process.on('SIGTERM', () => {
  securityManager.destroy();
});

process.on('SIGINT', () => {
  securityManager.destroy();
}); 