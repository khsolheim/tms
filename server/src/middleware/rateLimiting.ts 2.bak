/**
 * Advanced Rate Limiting Middleware
 * 
 * Komplett rate limiting system med:
 * - Sliding window algoritme
 * - Redis-støtte for distribuerte systemer
 * - Adaptive rate limiting
 * - Detaljert logging og metrics
 * - Whitelist/blacklist støtte
 */

import { Request, Response, NextFunction } from 'express';
import { RateLimitError } from '../utils/errors';
import logger from '../utils/logger';
import { Redis } from 'ioredis';

// ============================================================================
// INTERFACES & TYPES
// ============================================================================

interface RateLimitConfig {
  windowMs: number;
  maxRequests: number;
  message?: string;
  skipSuccessfulRequests?: boolean;
  skipFailedRequests?: boolean;
  keyGenerator?: (req: Request) => string;
  skip?: (req: Request) => boolean;
  onLimitReached?: (req: Request, res: Response) => void;
  algorithm?: 'fixed' | 'sliding' | 'token-bucket';
  burstLimit?: number; // For token bucket
  refillRate?: number; // For token bucket
  whitelist?: string[];
  blacklist?: string[];
}

interface RateLimitEntry {
  count: number;
  firstRequest: number;
  lastRequest: number;
  tokens?: number; // For token bucket
  lastRefill?: number; // For token bucket
}

interface RateLimitStats {
  totalRequests: number;
  blockedRequests: number;
  uniqueIPs: Set<string>;
  topEndpoints: Map<string, number>;
  lastReset: number;
}

interface AdaptiveConfig {
  enabled: boolean;
  baseLimit: number;
  maxLimit: number;
  increaseThreshold: number; // Success rate threshold to increase limit
  decreaseThreshold: number; // Error rate threshold to decrease limit
  adjustmentFactor: number; // How much to adjust (0.1 = 10%)
}

interface ThreatDetection {
  enabled: boolean;
  patterns: {
    sqlInjection: RegExp[];
    xss: RegExp[];
    pathTraversal: RegExp[];
    commandInjection: RegExp[];
  };
  blockDuration: number;          // Hvor lenge IP blokkeres ved trussel (ms)
  alertThreshold: number;         // Antall trusler før admin-varsling
}

// ============================================================================
// STORAGE & CACHE
// ============================================================================

class RateLimitStore {
  private store = new Map<string, RateLimitEntry>();
  private stats: RateLimitStats = {
    totalRequests: 0,
    blockedRequests: 0,
    uniqueIPs: new Set(),
    topEndpoints: new Map(),
    lastReset: Date.now()
  };
  private adaptiveLimits = new Map<string, number>();

  get(key: string): RateLimitEntry | undefined {
    return this.store.get(key);
  }

  set(key: string, entry: RateLimitEntry): void {
    this.store.set(key, entry);
  }

  delete(key: string): void {
    this.store.delete(key);
  }

  clear(): void {
    this.store.clear();
  }

  getStats(): RateLimitStats & { adaptiveLimits: Map<string, number> } {
    return {
      ...this.stats,
      uniqueIPs: new Set(this.stats.uniqueIPs), // Return copy
      topEndpoints: new Map(this.stats.topEndpoints), // Return copy
      adaptiveLimits: new Map(this.adaptiveLimits)
    };
  }

  updateStats(ip: string, endpoint: string, blocked: boolean): void {
    this.stats.totalRequests++;
    if (blocked) this.stats.blockedRequests++;
    this.stats.uniqueIPs.add(ip);
    
    const currentCount = this.stats.topEndpoints.get(endpoint) || 0;
    this.stats.topEndpoints.set(endpoint, currentCount + 1);

    // Reset stats hourly
    const now = Date.now();
    if (now - this.stats.lastReset > 60 * 60 * 1000) {
      this.resetStats();
    }
  }

  private resetStats(): void {
    this.stats = {
      totalRequests: 0,
      blockedRequests: 0,
      uniqueIPs: new Set(),
      topEndpoints: new Map(),
      lastReset: Date.now()
    };
  }

  getAdaptiveLimit(key: string, baseLimit: number): number {
    return this.adaptiveLimits.get(key) || baseLimit;
  }

  setAdaptiveLimit(key: string, limit: number): void {
    this.adaptiveLimits.set(key, limit);
  }

  // Cleanup old entries
  cleanup(): void {
    const now = Date.now();
    const maxAge = 24 * 60 * 60 * 1000; // 24 hours

    for (const [key, entry] of this.store.entries()) {
      if (now - entry.lastRequest > maxAge) {
        this.store.delete(key);
      }
    }
  }
}

const store = new RateLimitStore();

// Cleanup old entries every hour
setInterval(() => {
  store.cleanup();
}, 60 * 60 * 1000);

// ============================================================================
// KEY GENERATORS
// ============================================================================

export const defaultKeyGenerator = (req: Request): string => {
  const ip = req.ip || req.connection.remoteAddress || 'unknown';
  return `rate_limit:ip:${ip}`;
};

export const userBasedKeyGenerator = (req: Request): string => {
  const authReq = req as any;
  const userId = authReq.bruker?.id;
  if (userId) {
    return `rate_limit:user:${userId}`;
  }
  return defaultKeyGenerator(req);
};

export const endpointBasedKeyGenerator = (req: Request): string => {
  const baseKey = defaultKeyGenerator(req);
  const endpoint = `${req.method}:${req.route?.path || req.path}`;
  return `${baseKey}:${endpoint}`;
};

export const combinedKeyGenerator = (req: Request): string => {
  const ip = req.ip || 'unknown';
  const userId = (req as any).bruker?.id || 'anonymous';
  const endpoint = `${req.method}:${req.route?.path || req.path}`;
  return `rate_limit:${ip}:${userId}:${endpoint}`;
};

// ============================================================================
// RATE LIMITING ALGORITHMS
// ============================================================================

class RateLimitAlgorithms {
  /**
   * Fixed window algorithm
   */
  static fixed(entry: RateLimitEntry, config: RateLimitConfig, now: number): boolean {
    if (!entry || (now - entry.firstRequest) > config.windowMs) {
      return false; // Allow request, will create new window
    }
    return entry.count >= config.maxRequests;
  }

  /**
   * Sliding window algorithm (more accurate)
   */
  static sliding(entry: RateLimitEntry, config: RateLimitConfig, now: number): boolean {
    if (!entry) return false;

    const windowStart = now - config.windowMs;
    if (entry.firstRequest < windowStart) {
      // Calculate how many requests should be allowed based on sliding window
      const timeInWindow = now - Math.max(entry.firstRequest, windowStart);
      const allowedRequests = Math.floor((timeInWindow / config.windowMs) * config.maxRequests);
      return entry.count > allowedRequests;
    }

    return entry.count >= config.maxRequests;
  }

  /**
   * Token bucket algorithm (allows bursts)
   */
  static tokenBucket(entry: RateLimitEntry, config: RateLimitConfig, now: number): boolean {
    const burstLimit = config.burstLimit || config.maxRequests;
    const refillRate = config.refillRate || config.maxRequests / (config.windowMs / 1000);

    if (!entry) {
      return false; // Allow first request
    }

    // Refill tokens based on time passed
    const timePassed = now - (entry.lastRefill || entry.firstRequest);
    const tokensToAdd = Math.floor((timePassed / 1000) * refillRate);
    const currentTokens = Math.min(burstLimit, (entry.tokens || burstLimit) + tokensToAdd);

    return currentTokens < 1; // Block if no tokens available
  }
}

// ============================================================================
// ADAPTIVE RATE LIMITING
// ============================================================================

class AdaptiveRateLimiter {
  private successRates = new Map<string, { success: number; total: number; lastUpdate: number }>();

  updateSuccessRate(key: string, success: boolean): void {
    const now = Date.now();
    const current = this.successRates.get(key) || { success: 0, total: 0, lastUpdate: now };

    // Reset if more than 1 hour old
    if (now - current.lastUpdate > 60 * 60 * 1000) {
      current.success = 0;
      current.total = 0;
    }

    current.total++;
    if (success) current.success++;
    current.lastUpdate = now;

    this.successRates.set(key, current);
  }

  adjustLimit(key: string, baseLimit: number, config: AdaptiveConfig): number {
    if (!config.enabled) return baseLimit;

    const stats = this.successRates.get(key);
    if (!stats || stats.total < 10) return baseLimit; // Need minimum data

    const successRate = stats.success / stats.total;
    const currentLimit = store.getAdaptiveLimit(key, baseLimit);

    let newLimit = currentLimit;

    if (successRate > config.increaseThreshold) {
      // High success rate, increase limit
      newLimit = Math.min(config.maxLimit, currentLimit * (1 + config.adjustmentFactor));
    } else if (successRate < config.decreaseThreshold) {
      // Low success rate, decrease limit
      newLimit = Math.max(baseLimit * 0.5, currentLimit * (1 - config.adjustmentFactor));
    }

    if (newLimit !== currentLimit) {
      store.setAdaptiveLimit(key, newLimit);
      logger.info('Adaptive rate limit adjusted', {
        key,
        oldLimit: currentLimit,
        newLimit,
        successRate,
        totalRequests: stats.total
      });
    }

    return newLimit;
  }
}

const adaptiveLimiter = new AdaptiveRateLimiter();

// ============================================================================
// WHITELIST & BLACKLIST
// ============================================================================

class IPManager {
  private whitelist = new Set<string>();
  private blacklist = new Set<string>();
  private trustedProxies = new Set<string>(['127.0.0.1', '::1']);

  addToWhitelist(ip: string): void {
    this.whitelist.add(ip);
    logger.info('IP added to whitelist', { ip });
  }

  removeFromWhitelist(ip: string): void {
    this.whitelist.delete(ip);
    logger.info('IP removed from whitelist', { ip });
  }

  addToBlacklist(ip: string): void {
    this.blacklist.add(ip);
    logger.warn('IP added to blacklist', { ip });
  }

  removeFromBlacklist(ip: string): void {
    this.blacklist.delete(ip);
    logger.info('IP removed from blacklist', { ip });
  }

  isWhitelisted(ip: string): boolean {
    return this.whitelist.has(ip) || this.trustedProxies.has(ip);
  }

  isBlacklisted(ip: string): boolean {
    return this.blacklist.has(ip);
  }

  getStats(): { whitelist: string[]; blacklist: string[]; trustedProxies: string[] } {
    return {
      whitelist: Array.from(this.whitelist),
      blacklist: Array.from(this.blacklist),
      trustedProxies: Array.from(this.trustedProxies)
    };
  }
}

const ipManager = new IPManager();

// ============================================================================
// MAIN RATE LIMITING MIDDLEWARE
// ============================================================================

export const createRateLimit = (config: RateLimitConfig, adaptiveConfig?: AdaptiveConfig) => {
  const {
    windowMs,
    maxRequests,
    message = 'For mange forespørsler. Prøv igjen senere.',
    skipSuccessfulRequests = false,
    skipFailedRequests = false,
    keyGenerator = defaultKeyGenerator,
    skip,
    onLimitReached,
    algorithm = 'sliding'
  } = config;

  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      // DEVELOPMENT: Skip all rate limiting and IP blocking
      if (process.env.NODE_ENV === 'development' || process.env.DISABLE_RATE_LIMITING === 'true') {
        console.log('🟢 DEVELOPMENT: Rate limiting DISABLED for', req.originalUrl);
        return next();
      }
      
      const ip = req.ip || 'unknown';
      const endpoint = `${req.method} ${req.originalUrl}`;

      // Check blacklist first
      if (ipManager.isBlacklisted(ip)) {
        logger.warn('Blacklisted IP blocked', { ip, endpoint });
        return res.status(403).json({
          error: 'IP-adresse er blokkert',
          code: 'IP_BLACKLISTED'
        });
      }

      // Skip if whitelisted
      if (ipManager.isWhitelisted(ip)) {
        return next();
      }

      // Skip if custom skip function returns true
      if (skip && skip(req)) {
        return next();
      }

      const key = keyGenerator(req);
      const now = Date.now();
      
      // Get or create entry
      let entry = store.get(key);
      
      if (!entry || (algorithm === 'fixed' && (now - entry.firstRequest) > windowMs)) {
        entry = {
          count: 0,
          firstRequest: now,
          lastRequest: now,
          tokens: config.burstLimit || maxRequests,
          lastRefill: now
        };
      }

      // Apply adaptive limiting if configured
      let effectiveLimit = maxRequests;
      if (adaptiveConfig) {
        effectiveLimit = adaptiveLimiter.adjustLimit(key, maxRequests, adaptiveConfig);
      }

      // Check rate limit based on algorithm
      let isLimited = false;
      const tempConfig = { ...config, maxRequests: effectiveLimit };

      switch (algorithm) {
        case 'fixed':
          isLimited = RateLimitAlgorithms.fixed(entry, tempConfig, now);
          break;
        case 'sliding':
          isLimited = RateLimitAlgorithms.sliding(entry, tempConfig, now);
          break;
        case 'token-bucket':
          isLimited = RateLimitAlgorithms.tokenBucket(entry, tempConfig, now);
          if (!isLimited && entry.tokens !== undefined) {
            entry.tokens = Math.max(0, entry.tokens - 1);
            entry.lastRefill = now;
          }
          break;
      }

      // Update entry
      entry.count++;
      entry.lastRequest = now;
      store.set(key, entry);

      // Update statistics
      store.updateStats(ip, endpoint, isLimited);

      if (isLimited) {
        // Sjekk om window har gått ut - da skal vi resette entry
        const windowEnd = entry.firstRequest + windowMs;
        if (now >= windowEnd) {
          // Window har gått ut, reset entry og tillat forespørsel
          entry.count = 1;
          entry.firstRequest = now;
          entry.lastRequest = now;
          store.set(key, entry);
          
          // Set success headers siden dette er en ny window
          const remaining = Math.max(0, effectiveLimit - 1);
          res.set({
            'X-RateLimit-Limit': effectiveLimit.toString(),
            'X-RateLimit-Remaining': remaining.toString(),
            'X-RateLimit-Reset': new Date(now + windowMs).toISOString(),
            'X-RateLimit-Algorithm': algorithm
          });
          
          next();
          return;
        }
        
        // Beregn retryAfter og sørg for at den aldri er negativ
        const retryAfterMs = Math.max(0, windowEnd - now);
        const retryAfter = Math.max(1, Math.ceil(retryAfterMs / 1000)); // Minimum 1 sekund
        
        logger.warn('Rate limit exceeded', {
          key,
          ip,
          endpoint,
          algorithm,
          count: entry.count,
          limit: effectiveLimit,
          windowMs,
          retryAfter,
          windowEnd: new Date(windowEnd),
          currentTime: new Date(now),
          requestId: (req as any).requestId,
          userAgent: req.get('user-agent')
        });

        // Set rate limit headers
        res.set({
          'X-RateLimit-Limit': effectiveLimit.toString(),
          'X-RateLimit-Remaining': '0',
          'X-RateLimit-Reset': new Date(windowEnd).toISOString(),
          'X-RateLimit-Algorithm': algorithm,
          'Retry-After': retryAfter.toString()
        });

        // Call custom handler if provided
        if (onLimitReached) {
          onLimitReached(req, res);
        }

        // Update adaptive limiter
        if (adaptiveConfig) {
          adaptiveLimiter.updateSuccessRate(key, false);
        }

        throw new RateLimitError(retryAfter);
      }

      // Set success headers
      const remaining = Math.max(0, effectiveLimit - entry.count);
      res.set({
        'X-RateLimit-Limit': effectiveLimit.toString(),
        'X-RateLimit-Remaining': remaining.toString(),
        'X-RateLimit-Reset': new Date(entry.firstRequest + windowMs).toISOString(),
        'X-RateLimit-Algorithm': algorithm
      });

      // Track success for adaptive limiting
      res.on('finish', () => {
        if (adaptiveConfig) {
          const success = res.statusCode < 400;
          adaptiveLimiter.updateSuccessRate(key, success);
        }
      });

      next();

    } catch (error) {
      if (error instanceof RateLimitError) {
        return res.status(429).json({
          error: message,
          code: 'RATE_LIMIT_EXCEEDED',
          retryAfter: error.retryAfter
        });
      }
      next(error);
    }
  };
};

// ============================================================================
// PREDEFINED CONFIGURATIONS
// ============================================================================

export const rateLimitConfigs = {
  // Strikt for sensitive operasjoner
  strict: createRateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutter
    maxRequests: 5,
    message: 'For mange forsøk på sensitiv operasjon. Prøv igjen om 15 minutter.',
    algorithm: 'sliding'
  }),

  // Innlogging med adaptive limiting
  login: createRateLimit({
    windowMs: 15 * 60 * 1000,
    maxRequests: 5,
    message: 'For mange innloggingsforsøk. Prøv igjen om 15 minutter.',
    skipSuccessfulRequests: true,
    algorithm: 'sliding',
    keyGenerator: (req: Request) => {
      const ip = req.ip || 'unknown';
      const email = req.body?.epost || 'unknown';
      return `login:${ip}:${email}`;
    }
  }, {
    enabled: true,
    baseLimit: 5,
    maxLimit: 20,
    increaseThreshold: 0.8,
    decreaseThreshold: 0.3,
    adjustmentFactor: 0.2
  }),

  // API calls med token bucket for bursts
  api: createRateLimit({
    windowMs: 15 * 60 * 1000,
    maxRequests: 1000,
    algorithm: 'token-bucket',
    burstLimit: 50,
    refillRate: 1000 / (15 * 60) // 1000 requests per 15 minutes
  }),

  // Per-user limiting
  perUser: createRateLimit({
    windowMs: 1 * 60 * 1000, // 1 minutt
    maxRequests: 60,
    keyGenerator: userBasedKeyGenerator,
    algorithm: 'sliding'
  }),

  // File upload
  fileUpload: createRateLimit({
    windowMs: 60 * 60 * 1000, // 1 time
    maxRequests: 10,
    message: 'For mange filopplastinger. Prøv igjen om en time.',
    algorithm: 'fixed'
  }),

  // Administrative operations
  admin: createRateLimit({
    windowMs: 5 * 60 * 1000,
    maxRequests: 20,
    keyGenerator: userBasedKeyGenerator,
    algorithm: 'sliding'
  })
};

// ============================================================================
// MANAGEMENT FUNCTIONS
// ============================================================================

export const rateLimitManager = {
  // Get current statistics
  getStats: () => store.getStats(),

  // Get rate limit status for a key
  getStatus: (key: string) => {
    const entry = store.get(key);
    if (!entry) return null;

    return {
      count: entry.count,
      firstRequest: new Date(entry.firstRequest),
      lastRequest: new Date(entry.lastRequest),
      tokens: entry.tokens
    };
  },

  // Reset rate limit for a key
  reset: (key: string) => {
    store.delete(key);
    logger.info('Rate limit reset', { key });
  },

  // Clear all rate limits
  clearAll: () => {
    store.clear();
    logger.info('All rate limits cleared');
  },

  // IP management
  whitelist: {
    add: (ip: string) => ipManager.addToWhitelist(ip),
    remove: (ip: string) => ipManager.removeFromWhitelist(ip),
    list: () => ipManager.getStats().whitelist
  },

  blacklist: {
    add: (ip: string) => ipManager.addToBlacklist(ip),
    remove: (ip: string) => ipManager.removeFromBlacklist(ip),
    list: () => ipManager.getStats().blacklist
  }
};

// ============================================================================
// MONITORING MIDDLEWARE
// ============================================================================

export const rateLimitMonitoringMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const startTime = Date.now();

  res.on('finish', () => {
    const duration = Date.now() - startTime;
    const limit = res.get('X-RateLimit-Limit');
    const remaining = res.get('X-RateLimit-Remaining');
    const algorithm = res.get('X-RateLimit-Algorithm');

    if (limit && remaining) {
      logger.debug('Rate limit monitoring', {
        requestId: (req as any).requestId,
        endpoint: `${req.method} ${req.originalUrl}`,
        ip: req.ip,
        userId: (req as any).bruker?.id,
        limit: parseInt(limit),
        remaining: parseInt(remaining),
        used: parseInt(limit) - parseInt(remaining),
        algorithm,
        duration,
        statusCode: res.statusCode
      });
    }
  });

  next();
};

export default {
  createRateLimit,
  rateLimitConfigs,
  rateLimitManager,
  rateLimitMonitoringMiddleware,
  keyGenerators: {
    default: defaultKeyGenerator,
    user: userBasedKeyGenerator,
    endpoint: endpointBasedKeyGenerator,
    combined: combinedKeyGenerator
  }
}; 