import winston from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';
import path from 'path';

// ============================================================================
// LOGGING CONFIGURATION & TYPES
// ============================================================================

interface LogContext {
  requestId?: string;
  userId?: number;
  sessionId?: string;
  ip?: string;
  userAgent?: string;
  correlationId?: string;
  traceId?: string;
  spanId?: string;
}

interface AuditLogEntry {
  userId: number;
  action: string;
  resource: string;
  resourceId?: string | number;
  oldValue?: any;
  newValue?: any;
  ip?: string;
  userAgent?: string;
  success: boolean;
  errorMessage?: string;
  metadata?: any;
}

interface PerformanceLogEntry {
  operation: string;
  duration: number;
  endpoint?: string;
  method?: string;
  statusCode?: number;
  queryCount?: number;
  memoryUsage?: number;
  cpuUsage?: number;
  metadata?: any;
}

interface SecurityLogEntry {
  event: 'login_attempt' | 'login_success' | 'login_failure' | 'permission_denied' | 'suspicious_activity' | 'rate_limit_exceeded';
  userId?: number;
  ip: string;
  userAgent?: string;
  details?: any;
  severity: 'low' | 'medium' | 'high' | 'critical';
}

interface LogMetrics {
  totalLogs: number;
  errorCount: number;
  warnCount: number;
  infoCount: number;
  debugCount: number;
  auditCount: number;
  securityCount: number;
  performanceCount: number;
  slowOperations: number;
  lastReset: Date;
}

// ============================================================================
// ENHANCED LOGGER CLASS
// ============================================================================

class EnhancedLogger {
  private winston: winston.Logger;
  private metrics: LogMetrics;
  private alertThresholds: {
    errorRate: number;
    slowOperationThreshold: number;
    securityEventThreshold: number;
  };

  constructor() {
    this.metrics = {
      totalLogs: 0,
      errorCount: 0,
      warnCount: 0,
      infoCount: 0,
      debugCount: 0,
      auditCount: 0,
      securityCount: 0,
      performanceCount: 0,
      slowOperations: 0,
      lastReset: new Date()
    };

    this.alertThresholds = {
      errorRate: 0.1, // 10% error rate
      slowOperationThreshold: 2000, // 2 seconds
      securityEventThreshold: 10 // 10 security events per hour
    };

    this.winston = this.createWinstonLogger();
    this.setupMetricsReset();
  }

  private createWinstonLogger(): winston.Logger {
    // Define log levels with priorities
    const levels = {
      error: 0,
      warn: 1,
      info: 2,
      http: 3,
      debug: 4,
      audit: 5,
      security: 6,
      performance: 7
    };

    // Define colors for console output
    const colors = {
      error: 'red',
      warn: 'yellow',
      info: 'green',
      http: 'magenta',
      debug: 'blue',
      audit: 'cyan',
      security: 'red bold',
      performance: 'yellow'
    };

    winston.addColors(colors);

    // Enhanced format with more context
    const enhancedFormat = winston.format.combine(
      winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
      winston.format.errors({ stack: true }),
      winston.format.metadata({ fillExcept: ['message', 'level', 'timestamp'] }),
      winston.format.json()
    );

         // Console format for development
     const consoleFormat = winston.format.combine(
       winston.format.colorize({ all: true }),
       winston.format.timestamp({ format: 'HH:mm:ss.SSS' }),
       winston.format.printf(({ timestamp, level, message, metadata }: any) => {
         let msg = `${timestamp} [${level}]: ${message}`;
         
         // Add context information if available
         if (metadata && typeof metadata === 'object') {
           if (metadata.requestId) msg += ` [req:${metadata.requestId.toString().substring(0, 8)}]`;
           if (metadata.userId) msg += ` [user:${metadata.userId}]`;
           if (metadata.duration) msg += ` [${metadata.duration}ms]`;
           
           // Add metadata if present (excluding already shown fields)
           const filteredMeta = { ...metadata };
           delete filteredMeta.requestId;
           delete filteredMeta.userId;
           delete filteredMeta.duration;
           
           if (Object.keys(filteredMeta).length > 0) {
             msg += ` ${JSON.stringify(filteredMeta)}`;
           }
         }
         
         return msg;
       })
     );

    // Create transports array
    const transports: winston.transport[] = [];

    // Console transport for development
    if (process.env.NODE_ENV !== 'production') {
      transports.push(
        new winston.transports.Console({
          format: consoleFormat,
          level: 'debug'
        })
      );
    }

    // File transports
    const logDir = path.join(__dirname, '../../logs');

    // General application logs
    transports.push(
      new DailyRotateFile({
        filename: path.join(logDir, 'application-%DATE%.log'),
        datePattern: 'YYYY-MM-DD',
        maxSize: '50m',
        maxFiles: '30d',
        format: enhancedFormat,
        level: 'debug'
      })
    );

    // Error logs (separate file)
    transports.push(
      new DailyRotateFile({
        filename: path.join(logDir, 'error-%DATE%.log'),
        datePattern: 'YYYY-MM-DD',
        maxSize: '20m',
        maxFiles: '90d',
        format: enhancedFormat,
        level: 'error'
      })
    );

    // Audit logs (separate file for compliance)
    transports.push(
      new DailyRotateFile({
        filename: path.join(logDir, 'audit-%DATE%.log'),
        datePattern: 'YYYY-MM-DD',
        maxSize: '100m',
        maxFiles: '365d', // Keep audit logs for 1 year
        format: enhancedFormat,
        level: 'audit'
      })
    );

    // Security logs (separate file for security events)
    transports.push(
      new DailyRotateFile({
        filename: path.join(logDir, 'security-%DATE%.log'),
        datePattern: 'YYYY-MM-DD',
        maxSize: '50m',
        maxFiles: '180d', // Keep security logs for 6 months
        format: enhancedFormat,
        level: 'security'
      })
    );

    // Performance logs (separate file for performance analysis)
    transports.push(
      new DailyRotateFile({
        filename: path.join(logDir, 'performance-%DATE%.log'),
        datePattern: 'YYYY-MM-DD',
        maxSize: '100m',
        maxFiles: '30d',
        format: enhancedFormat,
        level: 'performance'
      })
    );

    // HTTP access logs
    transports.push(
      new DailyRotateFile({
        filename: path.join(logDir, 'access-%DATE%.log'),
        datePattern: 'YYYY-MM-DD',
        maxSize: '100m',
        maxFiles: '30d',
        format: enhancedFormat,
        level: 'http'
      })
    );

    // Create logger instance
    return winston.createLogger({
      level: process.env.LOG_LEVEL || (process.env.NODE_ENV === 'production' ? 'info' : 'debug'),
      levels,
      format: enhancedFormat,
      transports,
      exitOnError: false,
      // Handle uncaught exceptions and rejections
      exceptionHandlers: [
        new DailyRotateFile({
          filename: path.join(logDir, 'exceptions-%DATE%.log'),
          datePattern: 'YYYY-MM-DD',
          maxSize: '20m',
          maxFiles: '30d'
        })
      ],
      rejectionHandlers: [
        new DailyRotateFile({
          filename: path.join(logDir, 'rejections-%DATE%.log'),
          datePattern: 'YYYY-MM-DD',
          maxSize: '20m',
          maxFiles: '30d'
        })
      ]
    });
  }

  private setupMetricsReset(): void {
    // Reset metrics every hour
    setInterval(() => {
      this.resetMetrics();
    }, 60 * 60 * 1000);
  }

  private updateMetrics(level: string): void {
    this.metrics.totalLogs++;
    
    switch (level) {
      case 'error':
        this.metrics.errorCount++;
        break;
      case 'warn':
        this.metrics.warnCount++;
        break;
      case 'info':
        this.metrics.infoCount++;
        break;
      case 'debug':
        this.metrics.debugCount++;
        break;
      case 'audit':
        this.metrics.auditCount++;
        break;
      case 'security':
        this.metrics.securityCount++;
        break;
      case 'performance':
        this.metrics.performanceCount++;
        break;
    }

    // Check for alerts
    this.checkAlerts();
  }

  private checkAlerts(): void {
    const errorRate = this.metrics.errorCount / Math.max(this.metrics.totalLogs, 1);
    
    // High error rate alert
    if (errorRate > this.alertThresholds.errorRate && this.metrics.totalLogs > 100) {
      this.winston.error('HIGH ERROR RATE DETECTED', {
        errorRate: (errorRate * 100).toFixed(2) + '%',
        errorCount: this.metrics.errorCount,
        totalLogs: this.metrics.totalLogs,
        alert: true
      });
    }

    // High security event rate
    if (this.metrics.securityCount > this.alertThresholds.securityEventThreshold) {
      this.winston.error('HIGH SECURITY EVENT RATE DETECTED', {
        securityEvents: this.metrics.securityCount,
        threshold: this.alertThresholds.securityEventThreshold,
        alert: true
      });
    }
  }

  private resetMetrics(): void {
    this.metrics = {
      totalLogs: 0,
      errorCount: 0,
      warnCount: 0,
      infoCount: 0,
      debugCount: 0,
      auditCount: 0,
      securityCount: 0,
      performanceCount: 0,
      slowOperations: 0,
      lastReset: new Date()
    };
  }

  // ============================================================================
  // PUBLIC LOGGING METHODS
  // ============================================================================

  public error(message: string, context?: LogContext & any): void {
    this.updateMetrics('error');
    this.winston.error(message, context);
  }

  public warn(message: string, context?: LogContext & any): void {
    this.updateMetrics('warn');
    this.winston.warn(message, context);
  }

  public info(message: string, context?: LogContext & any): void {
    this.updateMetrics('info');
    this.winston.info(message, context);
  }

  public debug(message: string, context?: LogContext & any): void {
    this.updateMetrics('debug');
    this.winston.debug(message, context);
  }

  public http(message: string, context?: LogContext & any): void {
    this.winston.http(message, context);
  }

  // ============================================================================
  // SPECIALIZED LOGGING METHODS
  // ============================================================================

  public audit(entry: AuditLogEntry): void {
    this.updateMetrics('audit');
    this.winston.log('audit', 'AUDIT_EVENT', {
      ...entry,
      timestamp: new Date().toISOString(),
      type: 'audit'
    });
  }

  public security(entry: SecurityLogEntry): void {
    this.updateMetrics('security');
    this.winston.log('security', `SECURITY_EVENT: ${entry.event}`, {
      ...entry,
      timestamp: new Date().toISOString(),
      type: 'security'
    });

    // Log critical security events as errors too
    if (entry.severity === 'critical') {
      this.error(`Critical security event: ${entry.event}`, entry);
    }
  }

  public performance(entry: PerformanceLogEntry): void {
    this.updateMetrics('performance');
    
    // Track slow operations
    if (entry.duration > this.alertThresholds.slowOperationThreshold) {
      this.metrics.slowOperations++;
    }

    const level = entry.duration > this.alertThresholds.slowOperationThreshold ? 'warn' : 'info';
    
    this.winston.log('performance', `PERFORMANCE: ${entry.operation}`, {
      ...entry,
      timestamp: new Date().toISOString(),
      type: 'performance',
      slow: entry.duration > this.alertThresholds.slowOperationThreshold
    });

    // Also log as warning if very slow
    if (entry.duration > this.alertThresholds.slowOperationThreshold) {
      this.warn(`Slow operation detected: ${entry.operation}`, {
        duration: entry.duration,
        threshold: this.alertThresholds.slowOperationThreshold
      });
    }
  }

  // ============================================================================
  // UTILITY METHODS
  // ============================================================================

  public withContext(context: LogContext) {
    return {
      error: (message: string, meta?: any) => this.error(message, { ...context, ...meta }),
      warn: (message: string, meta?: any) => this.warn(message, { ...context, ...meta }),
      info: (message: string, meta?: any) => this.info(message, { ...context, ...meta }),
      debug: (message: string, meta?: any) => this.debug(message, { ...context, ...meta }),
      http: (message: string, meta?: any) => this.http(message, { ...context, ...meta })
    };
  }

  public getMetrics(): LogMetrics {
    return { ...this.metrics };
  }

  public setAlertThresholds(thresholds: Partial<typeof this.alertThresholds>): void {
    this.alertThresholds = { ...this.alertThresholds, ...thresholds };
  }

  // Create a stream for HTTP logging middleware
  public getHttpStream() {
    return {
      write: (message: string) => {
        this.http(message.trim());
      }
    };
  }

  // Method to flush all logs (useful for testing and shutdown)
  public async flush(): Promise<void> {
    return new Promise((resolve) => {
      this.winston.on('finish', resolve);
      this.winston.end();
    });
  }
}

// ============================================================================
// SINGLETON INSTANCE AND EXPORTS
// ============================================================================

const logger = new EnhancedLogger();

// Legacy compatibility exports
export const stream = logger.getHttpStream();

export const logWithCorrelationId = (correlationId: string, level: string, message: string, meta?: any) => {
  const context = { correlationId, ...meta };
  switch (level) {
    case 'error':
      logger.error(message, context);
      break;
    case 'warn':
      logger.warn(message, context);
      break;
    case 'info':
      logger.info(message, context);
      break;
    case 'debug':
      logger.debug(message, context);
      break;
    default:
      logger.info(message, context);
  }
};

export const auditLog = (userId: number, action: string, resource: string, details?: any) => {
  logger.audit({
    userId,
    action,
    resource,
    success: true,
    metadata: details
  });
};

export const performanceLog = (operation: string, duration: number, meta?: any) => {
  logger.performance({
    operation,
    duration,
    ...meta
  });
};

// New enhanced exports
export const securityLog = (entry: SecurityLogEntry) => logger.security(entry);
export const auditLogDetailed = (entry: AuditLogEntry) => logger.audit(entry);
export const performanceLogDetailed = (entry: PerformanceLogEntry) => logger.performance(entry);

export default logger; 